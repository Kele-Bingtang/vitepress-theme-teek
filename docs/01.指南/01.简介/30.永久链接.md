---
title: 永久链接
date: 2025-08-23 17:19:49
permalink: /guide/permalink
categories:
  - 指南
tags:
  - 指南
---

## 永久链接

VitePress 默认以 Markdown 文件路径作为链接访问，这会存在一个缺陷，当文件路径改变时，链接也会改变（再访问原来链接就会 404），在配置侧边栏、导航栏、各个文档链接引用、分享等场景时造成很大困扰。

因此需要给文件添加一个 **永久链接**，无论文件路径改变，访问链接不会改变。

Teek 使用 [vitepress-plugin-permalink](https://github.com/Kele-Bingtang/vitepress-theme-teek/blob/master/plugins/vitepress-plugin-permalink) 来实现永久链接功能。

插件已经内置到 Teek 中，你只需要在 Markdown 文件的 `frontmatter` 中添加如下内容：

```yaml
---
permalink: /guide/quickstart
---
```

这样就可以通过 `/guide/quickstart` 访问该页面了。

如果您不需要永久链接功能，请不配置 `permalink` 或者直接禁用该插件：

```ts
import { defineTeekConfig } from "vitepress-theme-teek/config";

const teekConfig = defineTeekConfig({
  vitePlugins: {
    permalink: false, // 禁用该插件
  },
});
```

## 永久链接方式

`vitepress-plugin-permalink` 插件提供两种方式实现永久链接：

1. `Proxy` 方式
2. `Rewrites` 方式

`Proxy` 方式不会影响文件路径，而是在访问文件路径时，通过代理（拦截）将其转换 `Permalink`，因此既可以通过文件路径访问，也可以通过 `Permalink` 访问。

`Rewrites` 方式在项目运行或者构建时，通过改变文件路径达到永久链接功能，你可以在构建的 `dist` 文件夹查看修改后的文件路径。

两者只能二选一，如果都配置，则以 `Rewrites` 方式为主。

Teek 默认为 `Proxy` 方式，如果替换为 `Rewrites` 方式，在 `config.mts` 里添加如下代码：

```ts
import { defineConfig } from "vitepress";
import { createRewrites } from "vitepress-theme-teek/config";

export default defineConfig({
  rewrites: createRewrites(/** options */),
});
```

`createRewrites` 函数支持除了传入 `vitepress-plugin-permalink` 的 [配置项](https://github.com/Kele-Bingtang/vitepress-theme-teek/blob/master/plugins/vitepress-plugin-permalink/src/types.ts)，也支持额外传入两个配置项：

- `srcDir`：VitePress 的 [srcDir](https://vitepress.dev/zh/reference/site-config#srcdir)，默认为 `.`，即当前项目的绝对目录
- `locales`：VitePress 的 [locales](https://vitepress.dev/zh/guide/i18n#internationalization)

如果没有传入配置项，则默认为从文档的根目录进行扫描。

## 侧边栏方式

Teek 使用 [vitepress-plugin-sidebar-resolve](https://github.com/Kele-Bingtang/vitepress-theme-teek/blob/master/plugins/vitepress-plugin-sidebar-resolve) 来实现自动生成侧边栏功能。

默认情况下，Teek 按照项目的目录结构生成侧边栏，如果你修改永久链接方式为 `rewrites`，则目录结构作为侧边栏将会失效，因此需要手动开启 `rewrites` 生成侧边栏。

通过 `resolveRule` 配置项来配置侧边栏生成规则：

- 当 `resolveRule` 为 `filePath`，则按照本地文件路径生成侧边栏
- 当 `resolveRule` 为 `rewrites`，则按照 `rewrites` 结果生成侧边栏

```ts
import { defineConfig } from "vitepress";
import { createRewrites } from "vitepress-theme-teek/config";

export default defineConfig({
  rewrites: createRewrites(),
  vite: {
    plugins: [
      Sidebar({
        resolveRule: "rewrites",
      }),
    ],
  },
});
```

如果 `resolveRule` 为 `rewrites`，但是没有 `rewrites` 配置，则按照 `filePath` 配置生成侧边栏。

## 什么是 rewrites

`rewrites` 是什么？，请看 VitePress 的 [路由重写](https://vitepress.dev/zh/guide/routing#route-rewrites) 描述。

这里简单说下个人理解，`filePath` 称之为 **本地文件路径**，`rewrites` 称之为 **运行文件路径**。

本地文件路径通俗易懂，那什么是运行文件路径？

我们访问的 VitePress 文档的链接地址就是 **运行文件路径**。VitePress 启动后，默认会将本地文件路径当作运行文件路径，但是我们可以通过 `rewrites` 将本地文件路径重写为新的文件路径，新的文件路径就会取代本地文件路径成为运行文件路径。

假设文件 `quick-start.md` 在本地路径为 `guide/quick-start.md`，在 `rewrites` 中添加如下配置：

```ts
import { defineConfig } from "vitepress";

export default defineConfig({
  rewrites: {
    "guide/quick-start.md": "/config/quick.md",
  },
});
```

此时该文件的运行文件路径为 `/config/quick` 而不是 `/guide/quick-start`。

## 调整文档frontmatter

通过上述我们了解到页面的 `永久链接` 其实就是 Markdown 文档 `frontmatter` 的 `permalink` 内容。

无论选择 `Proxy` 还是 `Rewrites` 方式都需要可以快捷自定义 `permalink`。

尤其是在 `Rewrites` 的模式下，需要保证一级目录下 `permalink` 的一级前缀一致，这是为了让侧边栏能够正常显示。

### 如何快捷自定义permalink

快捷自定义 `permalink`，其实就是修改Markdown 文档 `frontmatter` 的内容，可以借助 `vitepress-plugin-auto-frontmatter` 插件来完成。

在 Teek 中对 `vitepress-plugin-auto-frontmatter` 插件进行了增强，额外实现了一些常用的功能，使用相应的配置可以快速调整 `permalink`和 `coverImg` 等。

对 `frontmatter` 的内容进行调整完毕后，如果没有变更，可以选择**关闭一些功能**，跳过相关的检查以提升启动速度。

例如调整完 `permalink` 可以将 `enablePermalink` 设置为 `false`。

#### 提示

- 插件默认跳过 `frontmatter.layout` 设置为`home` 或 `false` 的Markdown 文档
- `permalink` 处理时默认跳过 `frontmatter.catalogue` 设置为`true` 的Markdown 文档 **（目录页）**
- 开启 `permalink` 功能但未提供 `permalinkRules` 规则时，会使用**默认规则**：`{ folderName: "*", prefix: "/$path/$uuid5" }` ，使用时推荐**根据目录手动编写自定义规则**，这样可以生成更加友好的访问链接
- 默认情况下在 `frontmatter` 中遇到同名的key会跳过，如果希望覆盖同名key，需要将 `recoverTransform` 设置为 `true`（主要是处理 `permalink` 和 `coverImg` 会用到）

#### 使用

在 Teek 的配置中的 `autoFrontmatterOption` 选项中可以进行配置。

更详细的使用方法可以阅读下方的 [配置](#配置)

```ts
export const teekConfig = defineTeekConfig({
	vitePlugins: {
		autoFrontmatter: true, // 自动生成 frontmatter
		autoFrontmatterOption: {
			// 是否开启同名key覆盖
			recoverTransform: false,
			// 是否开启自动生成 categories
			categories: true,
			// 是否开启添加文档封面图
			enableCoverImg: true,
			// 是否开启强制覆盖封面图，
			enableForceCoverImg: true,
			// 封面图列表
			coverImgList: ["1.webp", "2.webp", "3.webp"],
			// 是否开启生成永久链接
			enablePermalink: false,
			// 处理永久链接的规则
			permalinkRules: [
				{ folderName: "01.指南/XXX/", prefix: "/$path/$uuid", removeLevel: 99 }
			],
			// 是否开启时区转换
			enableHandleTimezone: true,
		},
	}
});
```



#### 配置

使用 Teek 中的增强功能时，请先阅读下方的配置项

```ts
import { AutoFrontmatterOption } from "vitepress-plugin-auto-frontmatter";

/**
 * 扩展后的自定义 AutoFrontmatter 配置接口
 * 继承原始 AutoFrontmatterOption，并添加自定义字段
 */
export interface TeekAutoFrontmatterOption extends AutoFrontmatterOption {
  /**
   * 是否开启自动生成 categories
   * 开启时根据文档目录自动生成分类
   * @default true（默认开启）
   */
  categories?: boolean;

  /**
   * 是否自动为无封面图的MD文档添加随机封面，根据coverImgList内容选择（coverImgList为空时无效）
   * 开启时：无封面图的MD文档，会自动添加封面图
   * @default false（默认关闭）
   */
  enableCoverImg?: boolean;

  /**
   * 是否开启强制覆盖封面图（coverImgList为空时无效）
   * 开启时：已有封面图的MD文档，会判断是否存在于coverImgList中，如果存在则跳过，如果不存在则覆盖掉原来的封面图。
   * 需要搭配 recoverTransform 一起使用，否则无法覆盖
   * @default false（默认关闭）
   */
  enableForceCoverImg?: boolean;

  /**
   * 封面图列表，填写封面图路径，支持本地路径和网络路径
   */
  coverImgList?: string[];

  /**
   * 是否开启生成永久链接 Permalink
   * 默认跳过 `frontmatter.catalogue` 设置为`true` 的Markdown 文档 （目录页）
   * 如果开启该功能，但未提供 permalinkRules 规则，则使用默认规则 { folderName: "*", prefix: "/$path/$uuid5" }
   * 需要搭配 recoverTransform 一起使用，否则无法覆盖
   * @default false（默认关闭）
   */
  enablePermalink?: boolean;

  /**
   * 处理 permalink 的规则配置
   * enablePermalink 设置为 false 时无效
   * @example
   * { folderName: "00.Teek", prefix: "/teek" } // 添加前缀
   * { folderName: "00.Teek/01.XXX", prefix: "/tool", removeLevel: 1 } // 先移除一层前缀，再添加前缀
   * { folderName: "00.Teek/01.XXX", prefix: "/test/$uuid5", removeLevel: 99} // 清空指定层级前缀并添加前缀，前缀使用随机数
   * { folderName: "00.Teek/01.XXX", prefix: "/test-$uuid4-$uuid2/aaa/", removeLevel: 99} // 混合固定字符串和随机数
   * { folderName: "00.Teek/01.XXX", prefix: "/note", clear: true } // 清空 permalink，此时prefix无效，clear优先级高
   * { folderName: "00.Teek/01.XXX", prefix: "/$path-$uuid2/teek/$uuid", removeLevel: 99 }, // 使用一级目录的哈希混合随机数
   * { folderName: "00.Teek/01.XXX", clear: true} // 清空前缀并且添加前缀使用随机数
   * { folderName: "*", clear: true}, // * 代表所有文件都匹配，清空所有文件的永久链接
   */
  permalinkRules?: TransformRule[];
}

/**
 * 定义规则类型
 * 如果第一个分组相同（即第一个斜杠的内容，只匹配一级，自动忽略纯空格），说明已包含目标前缀，不处理直接跳过
 * @param folderName 文件夹路径或文件名称
 *  - 文件夹路径：前缀匹配
 *  - 文件夹名称：精确匹配
 * @param prefix 可选：要添加的前缀，可以是多级的，例如/test-$uuid4-$uuid2/aaa/$uuid10/
 * @example
 * $UUID{n} 支持 $UUID, $UUID5, $UUID10 等格式，产生n位的随机字符串（数字加小写字母）
 * - n 默认5位
 * - n 取值[1 - 15]之间
 * - 不区分大小写
 * $PATH{n} 支持 $PATH, $PATH5，$PATH10 等格式， 代表一级目录并将其转为为hash值
 * - n 默认6位
 * - n 取值[6 - 10]之间，低于 6 按 6 处理（防止碰撞）
 * - 不区分大小写
 *
 * @param removeLevel 可选：要移除的前缀层级（以 / 分割），适合移除前缀并添加的场景（可以填写一个很大的数，那么就会全部清空再添加前缀）
 * @param clear 可选，是否清空 permalink，适合只想要清空的场景。true=清空，默认false（此时填写prefix无效，clear优先级高）
 */
export interface TransformRule {
  folderName: string;
  prefix?: string;
  removeLevel?: number;
  clear?: boolean;
}

```



